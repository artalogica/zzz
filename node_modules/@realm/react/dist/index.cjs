'use strict';

var React = require('react');
var Realm = require('realm');
var lodash = require('lodash');

/**
 * Generates a `useRealm` hook given a RealmContext.  This allows access to the {@link Realm}
 * instance anywhere within the RealmProvider.
 * @param RealmContext - The context containing the {@link Realm} instance
 * @returns useRealm - Hook that is used to gain access to the {@link Realm} instance
 */
const createUseRealm = (RealmContext) => {
    return function useRealm() {
        // This is the context setup by `createRealmContext`
        const context = React.useContext(RealmContext);
        if (context === null) {
            throw new Error("Realm context not found.  Did you call useRealm() within a <RealmProvider/>?");
        }
        return context;
    };
};

const numericRegEx = /^-?\d+$/;
function getCacheKey(id) {
    return `${id}`;
}
/**
 * Creates a proxy around a {@link Realm.Collection} that will create new {@link Realm.Object}
 * references on any relevant change (update, insert, deletion) and return the same
 * object reference if no changes have occurred since the last access.
 *
 * This makes the {@link Realm.Collection} behaves in an immutable way, as React expects, so
 * that a {@link Realm.Object} can be wrapped in {@link React.memo} to prevent unnecessary
 * rendering (see {@link useQuery} hook).
 *
 * @param args {@link CachedCollectionArgs} object arguments
 * @returns Proxy object wrapping the collection
 */
function createCachedCollection({ collection, realm, updateCallback, updatedRef, objectCache = new Map(), isDerived = false, }) {
    const cachedCollectionHandler = {
        get: function (target, key, receiver) {
            // Pass functions through
            const value = Reflect.get(target, key, receiver);
            if (typeof value === "function") {
                if (key === "sorted" || key === "filtered") {
                    return (...args) => {
                        const col = Reflect.apply(value, target, args);
                        const { collection: newCol } = createCachedCollection({
                            collection: col,
                            realm,
                            updateCallback,
                            updatedRef,
                            objectCache,
                            isDerived: true,
                        });
                        return newCol;
                    };
                }
                return value;
            }
            // If the key is not numeric, pass it through
            if (typeof key === "symbol" || !numericRegEx.test(key)) {
                return value;
            }
            // If the key is numeric, check if we have a cached object for this key
            const index = Number(key);
            const object = target[index];
            // If the collection is modeled in a way that objects can be null
            // then we should return null instead of undefined to stay semantically
            // correct
            if (object === null) {
                return null;
            }
            else if (typeof object === "undefined") {
                // If there is no object at this index, return undefined
                return undefined;
            }
            const objectId = object._objectKey();
            const cacheKey = getCacheKey(objectId);
            // If we do, return it...
            if (objectCache.get(cacheKey)) {
                return objectCache.get(cacheKey);
            }
            // If not then this index has either not been accessed before, or has been invalidated due
            // to a modification. Fetch it from the collection and store it in the cache
            objectCache.set(cacheKey, object);
            return object;
        },
    };
    const cachedCollectionResult = new Proxy(collection, cachedCollectionHandler);
    const listenerCallback = (listenerCollection, changes) => {
        if (changes.deletions.length > 0 || changes.insertions.length > 0 || changes.newModifications.length > 0) {
            // TODO: There is currently no way to rebuild the cache key from the changes array for deleted object.
            // Until it is possible, we clear the cache on deletions.
            // Blocking issue: https://github.com/realm/realm-core/issues/5220
            // Possible solutions:
            // a. the listenerCollection is a frozen copy of the collection before the deletion,
            // allowing accessing the _objectKey() using listenerCollection[index]._objectKey()
            // b. the callback provides an array of changed objectIds
            if (changes.deletions.length > 0) {
                objectCache.clear();
            }
            // Item(s) were modified, just clear them from the cache so that we return new instances for them
            changes.newModifications.forEach((index) => {
                const objectId = listenerCollection[index]._objectKey();
                if (objectId) {
                    const cacheKey = getCacheKey(objectId);
                    if (objectCache.has(cacheKey)) {
                        objectCache.delete(cacheKey);
                    }
                }
            });
            updatedRef.current = true;
            updateCallback();
        }
    };
    if (!isDerived) {
        // If we are in a transaction, then push adding the listener to the event loop.  This will allow the write transaction to finish.
        // see https://github.com/realm/realm-js/issues/4375
        if (realm.isInTransaction) {
            setImmediate(() => {
                collection.addListener(listenerCallback);
            });
        }
        else {
            collection.addListener(listenerCallback);
        }
    }
    const tearDown = () => {
        if (!isDerived) {
            collection.removeListener(listenerCallback);
            objectCache.clear();
        }
    };
    return { collection: cachedCollectionResult, tearDown };
}

// Convenience function that returns the correct type for the objectForPrimaryKey function
// Since we don't have a combined declaration for this function, typescript needs to know
// which return to use based on the typeof the type argument
function getObjectForPrimaryKey(realm, type, primaryKey) {
    return typeof type === "string"
        ? realm.objectForPrimaryKey(type, primaryKey)
        : realm.objectForPrimaryKey(type, primaryKey);
}
// Convenience function that returns the correct type for the objects function
// Since we don't have a combined declaration for this function, typescript needs to know
// which return to use based on the typeof the type argument
function getObjects(realm, type) {
    return (typeof type === "string" ? realm.objects(type) : realm.objects(type));
}

////////////////////////////////////////////////////////////////////////////
/**
 * Generates the `useQuery` hook from a given `useRealm` hook.
 * @param useRealm - Hook that returns an open Realm instance
 * @returns useObject - Hook that is used to gain access to a {@link Realm.Collection}
 */
function createUseQuery(useRealm) {
    function useQuery(type, query = (collection) => collection, deps = []) {
        const realm = useRealm();
        // We need to add the type to the deps, so that if the type changes, the query will be re-run.
        // This will be saved in an array which will be spread into the provided deps.
        const requiredDeps = [type];
        // Create a forceRerender function for the cachedCollection to use as its updateCallback, so that
        // the cachedCollection can force the component using this hook to re-render when a change occurs.
        const [, forceRerender] = React.useReducer((x) => x + 1, 0);
        const collectionRef = React.useRef();
        const updatedRef = React.useRef(true);
        const queryCallbackRef = React.useRef(null);
        // We want the user of this hook to be able pass in the `query` function inline (without the need to `useCallback` on it)
        // This means that the query function is unstable and will be a redefined on each render of the component where `useQuery` is used
        // Therefore we use the `deps` array to memoize the query function internally, and only use the returned `queryCallback`
        const queryCallback = React.useCallback(query, [...deps, ...requiredDeps]);
        // If the query function changes, we need to update the cachedCollection
        if (queryCallbackRef.current !== queryCallback) {
            queryCallbackRef.current = queryCallback;
            updatedRef.current = true;
        }
        const queryResult = React.useMemo(() => {
            return queryCallback(getObjects(realm, type));
        }, [type, realm, queryCallback]);
        // Wrap the cachedObject in useMemo, so we only replace it with a new instance if `realm` or `queryResult` change
        const { collection, tearDown } = React.useMemo(() => {
            return createCachedCollection({
                collection: queryResult,
                realm,
                updateCallback: forceRerender,
                updatedRef,
            });
        }, [realm, queryResult]);
        // Invoke the tearDown of the cachedCollection when useQuery is unmounted
        React.useEffect(() => {
            return tearDown;
        }, [tearDown]);
        // This makes sure the collection has a different reference on a rerender
        // Also we are ensuring the type returned is Realm.Results, as this is known in this context
        if (updatedRef.current) {
            updatedRef.current = false;
            collectionRef.current = new Proxy(collection, {});
        }
        // This will never not be defined, but the type system doesn't know that
        return collectionRef.current;
    }
    return useQuery;
}

////////////////////////////////////////////////////////////////////////////
/**
 * Creates a proxy around a {@link Realm.Object} that will return a new reference
 * on any relevant update to the object itself. It also wraps accesses to {@link Realm.List}
 * attributes into a {@link cachedCollection}, so that any update, insert or deletion to the
 * list will also return a new object reference.
 *
 * See {@link cachedCollection} and the `useObject` hook for description of how this
 * helps prevent unnecessary rendering.
 *
 * @param args - {@link CachedObjectArgs} object arguments
 * @returns Proxy object wrapping the {@link Realm.Object}
 */
function createCachedObject({ object, realm, updateCallback, updatedRef }) {
    const listCaches = new Map();
    const listTearDowns = [];
    // If the object doesn't exist, just return it with an noop tearDown
    //
    if (object === null) {
        return { object, tearDown: () => undefined };
    }
    // Create a cache for any Realm.List properties on the object
    for (const key of object.keys()) {
        //@ts-expect-error - TS doesn't know that the key is a valid property
        const value = object[key];
        if (value instanceof Realm.List && value.type === "object") {
            const updatedRef = { current: true };
            const { collection, tearDown } = createCachedCollection({ collection: value, realm, updateCallback, updatedRef });
            listCaches.set(key, { collection, updatedRef });
            listTearDowns.push(tearDown);
        }
    }
    // This Proxy handler intercepts any accesses into properties of the cached object
    // of type `Realm.List`, and returns a `cachedCollection` wrapping those properties
    // to allow changes in the list to trigger re-renders
    const cachedObjectHandler = {
        get: function (target, key, receiver) {
            const value = Reflect.get(target, key, receiver);
            // If its a Realm.List we need to add a proxy cache around it
            if (value instanceof Realm.List && value.type === "object") {
                if (listCaches.has(key)) {
                    // Return a new proxy wrapping the cachedCollection so that its reference gets updated,
                    // otherwise the list component will not re-render. The cachedCollection then ensures that
                    // only the modified children of the list component actually re-render.
                    const { collection, updatedRef } = listCaches.get(key);
                    if (updatedRef.current) {
                        updatedRef.current = false;
                        const proxyCollection = new Proxy(collection, {});
                        listCaches.set(key, { collection: proxyCollection, updatedRef });
                        return proxyCollection;
                    }
                    return collection;
                }
            }
            return value;
        },
    };
    const cachedObjectResult = new Proxy(object, cachedObjectHandler);
    const listenerCallback = (obj, changes) => {
        if (changes.deleted) {
            updateCallback();
        }
        else if (changes.changedProperties.length > 0) {
            // Don't force a second re-render if any of the changed properties is a Realm.List,
            // as the List's cachedCollection will force a re-render itself
            const anyListPropertyModified = changes.changedProperties.some((property) => {
                return obj[property] instanceof Realm.List && obj[property].type === "object";
            });
            const shouldRerender = !anyListPropertyModified;
            if (shouldRerender) {
                updateCallback();
            }
        }
        updatedRef.current = true;
    };
    // We cannot add a listener to an invalid object
    if (object.isValid()) {
        // If we are in a transaction, then push adding the listener to the event loop.  This will allow the write transaction to finish.
        // see https://github.com/realm/realm-js/issues/4375
        if (realm.isInTransaction) {
            setImmediate(() => {
                object.addListener(listenerCallback);
            });
        }
        else {
            object.addListener(listenerCallback);
        }
    }
    const tearDown = () => {
        object.removeListener(listenerCallback);
        for (const listTearDown of listTearDowns) {
            listTearDown();
        }
    };
    return { object: cachedObjectResult, tearDown };
}

////////////////////////////////////////////////////////////////////////////
/**
 * Generates the `useObject` hook from a given `useRealm` hook.
 * @param useRealm - Hook that returns an open Realm instance
 * @returns useObject - Hook that is used to gain access to a single Realm object from a primary key
 */
function createUseObject(useRealm) {
    function useObject(type, primaryKey) {
        const realm = useRealm();
        // Create a forceRerender function for the cachedObject to use as its updateCallback, so that
        // the cachedObject can force the component using this hook to re-render when a change occurs.
        const [, forceRerender] = React.useReducer((x) => x + 1, 0);
        // Get the original object from the realm, so we can check if it exists
        const originalObject = getObjectForPrimaryKey(realm, type, primaryKey);
        // Store the primaryKey as a ref, since when it is an objectId or UUID, it will be a new instance on every render
        const primaryKeyRef = React.useRef(primaryKey);
        const collectionRef = React.useRef(getObjects(realm, type));
        const objectRef = React.useRef();
        const updatedRef = React.useRef(true);
        // Initializing references with a function call or class constructor will
        // cause the function or constructor to be called on ever render.
        // Even though this value is thrown away on subsequent renders, `createCachedObject` will end up registering a listener.
        // Therefore, we initialize the references with null, and only create the object if it is null
        // Ref: https://github.com/facebook/react/issues/14490
        const cachedObjectRef = React.useRef(null);
        if (!cachedObjectRef.current) {
            cachedObjectRef.current = createCachedObject({
                object: originalObject ?? null,
                realm,
                updateCallback: forceRerender,
                updatedRef,
            });
        }
        // Create a ref, since the object returned from `objectForPrimaryKey` is always going to have a different reference
        const originalObjectRef = React.useRef(originalObject);
        // Wrap the cachedObject in useMemo, so we only replace it with a new instance if `primaryKey` or `type` change
        const { object, tearDown } = React.useMemo(
        // TODO: There will be an upcoming breaking change that makes objectForPrimaryKey return null
        // When this is implemented, remove `?? null`
        () => {
            // This should never happen, but if it does, we want to return a null result
            if (!cachedObjectRef.current) {
                return { object: null, tearDown: () => undefined };
            }
            // Re-instantiate the cachedObject if the primaryKey has changed or the originalObject has gone from null to not null
            if (!arePrimaryKeysIdentical(primaryKey, primaryKeyRef.current) ||
                (!originalObjectRef.current && originalObject)) {
                cachedObjectRef.current = createCachedObject({
                    object: originalObject ?? null,
                    realm,
                    updateCallback: forceRerender,
                    updatedRef,
                });
                originalObjectRef.current = originalObject;
                // Primary key has updated, so update the reference
                primaryKeyRef.current = primaryKey;
                // Signal that the object reference needs to be updated
                updatedRef.current = true;
            }
            return cachedObjectRef.current;
        }, [realm, originalObject, primaryKey]);
        // Invoke the tearDown of the cachedObject when useObject is unmounted
        React.useEffect(() => {
            return tearDown;
        }, [tearDown]);
        // If the object doesn't exist, listen for insertions to the collection and force a rerender if the inserted object has the correct primary key
        React.useEffect(() => {
            const collection = collectionRef.current;
            const collectionListener = (_, changes) => {
                const primaryKeyProperty = collection?.[0]?.objectSchema()?.primaryKey;
                for (const index of changes.insertions) {
                    const object = collection[index];
                    if (primaryKeyProperty) {
                        //@ts-expect-error - if the primaryKeyProperty exists, then it is indexable. However, we don't allow it when we don't actually know the type of the object
                        const insertedPrimaryKey = object[primaryKeyProperty];
                        if (arePrimaryKeysIdentical(insertedPrimaryKey, primaryKeyRef.current)) {
                            forceRerender();
                            collection.removeListener(collectionListener);
                            break;
                        }
                    }
                }
            };
            if (!originalObjectRef.current) {
                collection.addListener(collectionListener);
            }
            return () => {
                // If the app is closing, the realm will be closed and the listener does not need to be removed if
                if (!realm.isClosed && collection) {
                    collection.removeListener(collectionListener);
                }
            };
        }, [realm, type, forceRerender]);
        // If the object has been deleted or doesn't exist for the given primary key, just return null
        if (!object?.isValid()) {
            return null;
        }
        if (updatedRef.current) {
            // Wrap object in a proxy to update the reference on rerender ( should only rerender when something has changed )
            objectRef.current = new Proxy(object, {});
            updatedRef.current = false;
        }
        // This will never be undefined, but the type system doesn't know that
        return objectRef.current;
    }
    return useObject;
}
// This is a helper function that determines if two primary keys are equal.  It will also handle the case where the primary key is an ObjectId or UUID
function arePrimaryKeysIdentical(a, b) {
    if (typeof a !== typeof b) {
        return false;
    }
    if (typeof a === "string" || typeof a === "number") {
        return a === b;
    }
    if (a instanceof Realm.BSON.ObjectId && b instanceof Realm.BSON.ObjectId) {
        return a.toHexString() === b.toHexString();
    }
    if (a instanceof Realm.BSON.UUID && b instanceof Realm.BSON.UUID) {
        return a.toHexString() === b.toHexString();
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
exports.AuthOperationName = void 0;
(function (AuthOperationName) {
    AuthOperationName["LogIn"] = "logIn";
    AuthOperationName["LogInWithAnonymous"] = "logInWithAnonymous";
    AuthOperationName["LogInWithApiKey"] = "logInWithApiKey";
    AuthOperationName["LogInWithEmailPassword"] = "logInWithEmailPassword";
    AuthOperationName["LogInWithJWT"] = "logInWithJWT";
    AuthOperationName["LogInWithGoogle"] = "logInWithGoogle";
    AuthOperationName["LogInWithApple"] = "logInWithApple";
    AuthOperationName["LogInWithFacebook"] = "logInWithFacebook";
    AuthOperationName["LogInWithFunction"] = "logInWithFunction";
    AuthOperationName["LogOut"] = "logOut";
    AuthOperationName["Register"] = "register";
    AuthOperationName["Confirm"] = "confirm";
    AuthOperationName["ResendConfirmationEmail"] = "resendConfirmationEmail";
    AuthOperationName["RetryCustomConfirmation"] = "retryCustomConfirmation";
    AuthOperationName["SendResetPasswordEmail"] = "sendResetPasswordEmail";
    AuthOperationName["ResetPassword"] = "resetPassword";
    AuthOperationName["CallResetPasswordFunction"] = "callResetPasswordFunction";
})(exports.AuthOperationName || (exports.AuthOperationName = {}));
/**
 * The `AuthError` is set based on the operation name and the error message.
 */
class AuthError extends Error {
    constructor(operation, message) {
        super(message);
        this.name = "AuthError";
        this.operation = operation;
    }
}
/**
 * The possible states an {@link OperationResult} can be in.
 */
exports.OperationState = void 0;
(function (OperationState) {
    OperationState["NotStarted"] = "not-started";
    OperationState["Pending"] = "pending";
    OperationState["Success"] = "success";
    OperationState["Error"] = "error";
})(exports.OperationState || (exports.OperationState = {}));

////////////////////////////////////////////////////////////////////////////
/**
 * Create a context containing the Realm app.  Should be accessed with the useApp hook.
 */
const AppContext = React.createContext(null);
const AuthOperationContext = React.createContext(null);
const AuthOperationProvider = ({ children }) => {
    const [authOpResult, setAuthOpResult] = React.useState({
        state: exports.OperationState.NotStarted,
        pending: false,
        success: false,
        error: undefined,
        operation: null,
    });
    return (React.createElement(AuthOperationContext.Provider, { value: [authOpResult, setAuthOpResult] }, children));
};
/**
 * React component providing a Realm App instance on the context for the
 * sync hooks to use. An `AppProvider` is required for an app to use the hooks.
 * @param appProps - The {@link Realm.AppConfiguration} for app services, passed as props.
 * @param appRef - A ref to the app instance, which can be used to access the app instance outside of the React component tree.
 */
const AppProvider = ({ children, appRef, ...appProps }) => {
    const configuration = React.useRef(appProps);
    const [app, setApp] = React.useState(() => new Realm.App(configuration.current));
    // Support for a possible change in configuration
    if (!lodash.isEqual(appProps, configuration.current)) {
        configuration.current = appProps;
        try {
            setApp(new Realm.App(configuration.current));
        }
        catch (err) {
            console.error(err);
        }
    }
    React.useLayoutEffect(() => {
        if (appRef) {
            appRef.current = app;
        }
    }, [appRef, app]);
    return (React.createElement(AppContext.Provider, { value: app },
        React.createElement(AuthOperationProvider, null, children)));
};
/**
 * Hook to access the current {@link Realm.App} from the {@link AppProvider} context.
 * @throws if an AppProvider does not exist in the component’s ancestors
 */
const useApp = () => {
    const app = React.useContext(AppContext);
    if (!app) {
        throw new Error("No app found. Did you forget to wrap your component in an <AppProvider>?");
    }
    return app;
};
const useAuthResult = () => {
    const authOperationStateHook = React.useContext(AuthOperationContext);
    if (!authOperationStateHook) {
        throw new Error("Auth operation statue could not be determined. Did you forget to wrap your component in an <AppProvider>?");
    }
    return authOperationStateHook;
};

////////////////////////////////////////////////////////////////////////////
/**
 * Create a context containing the Realm app.  Should be accessed with the useApp hook.
 */
const UserContext = React.createContext(null);
/**
 * React component providing a Realm user on the context for the sync hooks
 * to use. A `UserProvider` is required for an app to use the hooks.
 */
const UserProvider = ({ fallback: Fallback, children }) => {
    const app = useApp();
    const [user, setUser] = React.useState(() => app.currentUser);
    // Support for a possible change in configuration
    if (app.currentUser?.id != user?.id) {
        setUser(app.currentUser);
    }
    React.useEffect(() => {
        const event = () => {
            setUser(app.currentUser);
        };
        user?.addListener(event);
        app?.addListener(event);
        return () => {
            user?.removeListener(event);
            app?.removeListener(event);
        };
    }, [user, app]);
    if (!user) {
        if (typeof Fallback === "function") {
            return React.createElement(Fallback, null);
        }
        return React.createElement(React.Fragment, null, Fallback);
    }
    return React.createElement(UserContext.Provider, { value: user }, children);
};
/**
 * Hook to access the currently authenticated Realm user from the
 * {@link UserProvider} context. The user is stored as React state,
 * so will trigger a re-render whenever it changes (e.g. logging in,
 * logging out, switching user).
 *
 */
const useUser = () => {
    const user = React.useContext(UserContext);
    if (!user) {
        throw new Error("No user found. Did you forget to wrap your component in a <UserProvider>?");
    }
    return user;
};

////////////////////////////////////////////////////////////////////////////
/**
 * Generates a `RealmProvider` given a {@link Realm.Configuration} and {@link React.Context}.
 * @param realmConfig - The configuration of the Realm to be instantiated
 * @param RealmContext - The context that will contain the Realm instance
 * @returns a RealmProvider component that provides context to all context hooks
 */
function createRealmProvider(realmConfig, RealmContext) {
    /**
     * Returns a Context Provider component that is required to wrap any component using
     * the Realm hooks.
     * @example
     * ```
     * const AppRoot = () => {
     *   const syncConfig = {
     *     flexible: true,
     *     user: currentUser
     *   };
     *
     *   return (
     *     <RealmProvider path="data.realm" sync={syncConfig}>
     *       <App/>
     *     </RealmProvider>
     *   )
     * }
     * ```
     * @param props - The {@link Realm.Configuration} for this Realm defaults to
     * the config passed to `createRealmProvider`, but individual config keys can
     * be overridden when creating a `<RealmProvider>` by passing them as props.
     * For example, to override the `path` config value, use a prop named `path`,
     * e.g. `path="newPath.realm"`
     */
    return ({ children, fallback: Fallback, closeOnUnmount = true, realmRef, ...restProps }) => {
        const [realm, setRealm] = React.useState(() => realmConfig.sync === undefined && restProps.sync === undefined
            ? new Realm(mergeRealmConfiguration(realmConfig, restProps))
            : null);
        // Automatically set the user in the configuration if its been set.
        // Grabbing directly from the context to avoid throwing an error if the user is not set.
        const user = React.useContext(UserContext);
        // We increment `configVersion` when a config override passed as a prop
        // changes, which triggers a `useEffect` to re-open the Realm with the
        // new config
        const [configVersion, setConfigVersion] = React.useState(0);
        // We put realm in a ref to avoid have an endless loop of updates when the realm is updated
        const currentRealm = React.useRef(realm);
        // This will merge the configuration provided by createRealmContext and any configuration properties
        // set directly on the RealmProvider component.  Any settings on the component will override the original configuration.
        const configuration = React.useRef(mergeRealmConfiguration(realmConfig, restProps));
        // Merge and set the configuration again and increment the version if any
        // of the RealmProvider properties change.
        React.useEffect(() => {
            const combinedConfig = mergeRealmConfiguration(realmConfig, restProps);
            // If there is a user in the current context and not one set by the props, then use the one from context
            const combinedConfigWithUser = combinedConfig?.sync && user ? mergeRealmConfiguration({ sync: { user } }, combinedConfig) : combinedConfig;
            if (!areConfigurationsIdentical(configuration.current, combinedConfigWithUser)) {
                configuration.current = combinedConfigWithUser;
                // Only rerender if realm has already been configured
                if (currentRealm.current != null) {
                    setConfigVersion((x) => x + 1);
                }
            }
        }, [restProps, user]);
        React.useEffect(() => {
            currentRealm.current = realm;
            if (realmRef) {
                realmRef.current = realm;
            }
        }, [realm]);
        React.useEffect(() => {
            const realmRef = currentRealm.current;
            // Check if we currently have an open Realm. If we do not (i.e. it is the first
            // render, or the Realm has been closed due to a config change), then we
            // need to open a new Realm.
            const shouldInitRealm = realmRef === null;
            const initRealm = async () => {
                const openRealm = await Realm.open(configuration.current);
                setRealm(openRealm);
            };
            if (shouldInitRealm) {
                initRealm().catch(console.error);
            }
            return () => {
                if (realm) {
                    if (closeOnUnmount) {
                        realm.close();
                    }
                    setRealm(null);
                }
            };
        }, [configVersion, realm, setRealm, closeOnUnmount]);
        if (!realm) {
            if (typeof Fallback === "function") {
                return React.createElement(Fallback, null);
            }
            return React.createElement(React.Fragment, null, Fallback);
        }
        return React.createElement(RealmContext.Provider, { value: realm, children: children });
    };
}
/**
 * Merge two configurations, creating a configuration using `configA` as the default,
 * merged with `configB`, with properties in `configB` overriding `configA`.
 * @param configA - The default config object
 * @param configB - Config overrides object
 * @returns Merged config object
 */
function mergeRealmConfiguration(configA, configB) {
    // In order to granularly update sync properties on the RealmProvider, sync must be
    // seperately applied to the configuration.  This allows for dynamic updates to the
    // partition field.
    const sync = { ...configA.sync, ...configB.sync };
    return {
        ...configA,
        ...configB,
        //TODO: When Realm >= 10.9.0 is a peer dependency, we can simply spread sync here
        //See issue #4012
        ...(Object.keys(sync).length > 0 ? { sync } : undefined),
    };
}
/**
 * Utility function that does a deep comparison (key: value) of object a with object b
 * @param a - Object to compare
 * @param b - Object to compare
 * @returns True if the objects are identical
 */
function areConfigurationsIdentical(a, b) {
    return lodash.isEqual(a, b);
}

////////////////////////////////////////////////////////////////////////////
function useAuthOperation({ operation, operationName, }) {
    const [result, setResult] = useAuthResult();
    return React.useCallback((...args) => {
        if (result.pending) {
            return Promise.reject("Another authentication operation is already in progress");
        }
        setResult({
            state: exports.OperationState.Pending,
            pending: true,
            success: false,
            error: undefined,
            operation: operationName,
        });
        operation(...args).then(() => {
            setResult({
                state: exports.OperationState.Success,
                pending: false,
                success: true,
                error: undefined,
                operation: operationName,
            });
        }, (error) => {
            const authError = new AuthError(operationName, error);
            setResult({
                state: exports.OperationState.Error,
                pending: false,
                success: false,
                error: authError,
                operation: operationName,
            });
        });
    }, [result, setResult, operation, operationName]);
}

////////////////////////////////////////////////////////////////////////////
/**
 * Hook providing operations and corresponding state for authenticating with an
 * Atlas App.
 *
 * The {@link AuthResult} values returned from this hook (e.g. `state`, `pending`, etc.) are
 * shared across all components under a given `AppProvider`, as only one operation can be in
 * progress at a given time (i.e. we will store the values on the context). This means that,
 * for example, multiple components can use the `useAuth` hook to access
 * `loginResult.pending` to render a spinner when login is in progress, without
 * needing to pass that state around or store it somewhere global in their app
 * code.
 * @returns An object containing operations and state for authenticating with an Atlas App.
 */
function useAuth() {
    const app = useApp();
    const [result] = useAuthResult();
    const logIn = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(credentials), [app]),
        operationName: exports.AuthOperationName.LogIn,
    });
    const logInWithAnonymous = useAuthOperation({
        operation: React.useCallback(() => app.logIn(Realm.Credentials.anonymous()), [app]),
        operationName: exports.AuthOperationName.LogInWithAnonymous,
    });
    const logInWithApiKey = useAuthOperation({
        operation: React.useCallback((key) => app.logIn(Realm.Credentials.apiKey(key)), [app]),
        operationName: exports.AuthOperationName.LogInWithApiKey,
    });
    const logInWithEmailPassword = useAuthOperation({
        operation: React.useCallback((params) => app.logIn(Realm.Credentials.emailPassword(params.email, params.password)), [app]),
        operationName: exports.AuthOperationName.LogInWithEmailPassword,
    });
    const logInWithJWT = useAuthOperation({
        operation: React.useCallback((token) => app.logIn(Realm.Credentials.jwt(token)), [app]),
        operationName: exports.AuthOperationName.LogInWithJWT,
    });
    const logInWithGoogle = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(Realm.Credentials.google(credentials)), [app]),
        operationName: exports.AuthOperationName.LogInWithGoogle,
    });
    const logInWithApple = useAuthOperation({
        operation: React.useCallback((idToken) => app.logIn(Realm.Credentials.apple(idToken)), [app]),
        operationName: exports.AuthOperationName.LogInWithApple,
    });
    const logInWithFacebook = useAuthOperation({
        operation: React.useCallback((accessToken) => app.logIn(Realm.Credentials.facebook(accessToken)), [app]),
        operationName: exports.AuthOperationName.LogInWithFacebook,
    });
    const logInWithFunction = useAuthOperation({
        operation: React.useCallback((payload) => app.logIn(Realm.Credentials.function(payload)), [app]),
        operationName: exports.AuthOperationName.LogInWithFunction,
    });
    const logOut = useAuthOperation({
        operation: React.useCallback(async () => app.currentUser?.logOut(), [app]),
        operationName: exports.AuthOperationName.LogOut,
    });
    return {
        result,
        logIn,
        logInWithAnonymous,
        logInWithApiKey,
        logInWithEmailPassword,
        logInWithJWT,
        logInWithGoogle,
        logInWithApple,
        logInWithFacebook,
        logInWithFunction,
        logOut,
    };
}

////////////////////////////////////////////////////////////////////////////
/**
 * Hook providing operations and corresponding state for authenticating with an
 * Atlas App with Email/Password.  It also contains operations related to
 * Email/Password authentication, such as resetting password and confirming a user.
 *
 * The {@link AuthResult} values returned from this hook (e.g. `state`, `pending`, etc.) are
 * shared across all components under a given `AppProvider`, as only one operation can be in
 * progress at a given time (i.e. we will store the values on the context). This means that,
 * for example, multiple components can use the `useEmailPasswordAuth` hook to access
 * `result.pending` to render a spinner when login is in progress, without
 * needing to pass that state around or store it somewhere global in their app
 * code.
 * @returns An object containing operations and state related to Email/Password authentication.
 */
function useEmailPasswordAuth() {
    const app = useApp();
    const [result] = useAuthResult();
    const logIn = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(Realm.Credentials.emailPassword(credentials)), [app]),
        operationName: exports.AuthOperationName.LogIn,
    });
    const register = useAuthOperation({
        operation: React.useCallback((credentials) => app.emailPasswordAuth.registerUser(credentials), [app]),
        operationName: exports.AuthOperationName.Register,
    });
    const confirm = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.confirmUser(args), [app]),
        operationName: exports.AuthOperationName.Confirm,
    });
    const resendConfirmationEmail = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.resendConfirmationEmail(args), [app]),
        operationName: exports.AuthOperationName.ResendConfirmationEmail,
    });
    const retryCustomConfirmation = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.retryCustomConfirmation(args), [app]),
        operationName: exports.AuthOperationName.RetryCustomConfirmation,
    });
    const sendResetPasswordEmail = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.sendResetPasswordEmail(args), [app]),
        operationName: exports.AuthOperationName.SendResetPasswordEmail,
    });
    const callResetPasswordFunction = useAuthOperation({
        operation: React.useCallback((credentials, ...restArgs) => app.emailPasswordAuth.callResetPasswordFunction(credentials, ...restArgs), [app]),
        operationName: exports.AuthOperationName.CallResetPasswordFunction,
    });
    const resetPassword = useAuthOperation({
        operation: (args) => app.emailPasswordAuth.resetPassword(args),
        operationName: exports.AuthOperationName.ResetPassword,
    });
    const logOut = useAuthOperation({
        operation: async () => app.currentUser?.logOut(),
        operationName: exports.AuthOperationName.LogOut,
    });
    return {
        result,
        logIn,
        register,
        resendConfirmationEmail,
        confirm,
        retryCustomConfirmation,
        sendResetPasswordEmail,
        callResetPasswordFunction,
        resetPassword,
        logOut,
    };
}

////////////////////////////////////////////////////////////////////////////
/**
 * Creates Realm React hooks and Provider component for a given Realm configuration
 * @example
 * ```
 *class Task extends Realm.Object {
 *  ...
 *
 *  static schema = {
 *    name: 'Task',
 *    primaryKey: '_id',
 *    properties: {
 *      ...
 *    },
 *  };
 *}
 *
 *const {useRealm, useQuery, useObject, RealmProvider} = createRealmContext({schema: [Task]});
 * ```
 * @param realmConfig - {@link Realm.Configuration} used to open the Realm
 * @returns An object containing a `RealmProvider` component, and `useRealm`, `useQuery` and `useObject` hooks
 */
const createRealmContext = (realmConfig = {}) => {
    const RealmContext = React.createContext(null);
    const RealmProvider = createRealmProvider(realmConfig, RealmContext);
    const useRealm = createUseRealm(RealmContext);
    const useQuery = createUseQuery(useRealm);
    const useObject = createUseObject(useRealm);
    return {
        RealmProvider,
        useRealm,
        useQuery,
        useObject,
    };
};
const defaultContext = createRealmContext();
/**
 * The Provider component that is required to wrap any component using
 * the Realm hooks.
 * @example
 * ```
 * const AppRoot = () => {
 *   const syncConfig = {
 *     flexible: true,
 *     user: currentUser
 *   };
 *
 *   return (
 *     <RealmProvider schema={[Task, User]} path={"data.realm"} sync={syncConfig}>
 *       <App/>
 *     </RealmProvider>
 *   )
 * }
 * ```
 * @param props - The {@link Realm.Configuration} for this Realm, passed as props.
 * By default, this is the main configuration for the Realm.
 */
const RealmProvider = defaultContext.RealmProvider;
/**
 * Returns the instance of the {@link Realm} opened by the `RealmProvider`.
 * @example
 * ```
 * const realm = useRealm();
 * ```
 * @returns a realm instance
 */
const useRealm = defaultContext.useRealm;
/**
 * Returns a {@link Realm.Collection} of {@link Realm.Object}s from a given type.
 * The hook will update on any changes to any object in the collection
 * and return an empty array if the collection is empty.
 *
 * The result of this can be consumed directly by the `data` argument of any React Native
 * VirtualizedList or FlatList.  If the component used for the list's `renderItem` prop is {@link React.Memo}ized,
 * then only the modified object will re-render.
 * @example
 * ```tsx
 * // Return all collection items
 * const collection = useQuery(Object)
 *
 * // Return all collection items sorted by name and filtered by category
 * const filteredAndSorted = useQuery(Object, (collection) => collection.filtered('category == $0',category).sorted('name'), [category]);
 * ```
 * @param type - The object type, depicted by a string or a class extending Realm.Object
 * @param query - A function that takes a {@link Realm.Collection} and returns a {@link Realm.Collection} of the same type.
 * This allows for filtering and sorting of the collection, before it is returned.
 * @param deps - An array of dependencies that will be passed to {@link React.useMemo}
 * @returns a collection of realm objects or an empty array
 */
const useQuery = defaultContext.useQuery;
/**
 * Returns a {@link Realm.Object} from a given type and value of primary key.
 * The hook will update on any changes to the properties on the returned object
 * and return null if it either doesn't exists or has been deleted.
 * @example
 * ```
 * const object = useObject(ObjectClass, objectId);
 * ```
 * @param type - The object type, depicted by a string or a class extending {@link Realm.Object}
 * @param primaryKey - The primary key of the desired object which will be retrieved using {@link Realm.objectForPrimaryKey}
 * @returns either the desired {@link Realm.Object} or `null` in the case of it being deleted or not existing.
 */
const useObject = defaultContext.useObject;

exports.Realm = Realm;
exports.AppProvider = AppProvider;
exports.AuthError = AuthError;
exports.RealmProvider = RealmProvider;
exports.UserProvider = UserProvider;
exports.createRealmContext = createRealmContext;
exports.useApp = useApp;
exports.useAuth = useAuth;
exports.useAuthResult = useAuthResult;
exports.useEmailPasswordAuth = useEmailPasswordAuth;
exports.useObject = useObject;
exports.useQuery = useQuery;
exports.useRealm = useRealm;
exports.useUser = useUser;
//# sourceMappingURL=index.cjs.map
