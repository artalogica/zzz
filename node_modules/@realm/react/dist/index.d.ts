/// <reference types="react" />
import Realm from "realm";
import { createUseRealm } from "./useRealm";
import { createUseQuery } from "./useQuery";
import { createUseObject } from "./useObject";
import { createRealmProvider } from "./RealmProvider";
type RealmContext = {
    /**
     * The Provider component that is required to wrap any component using
     * the Realm hooks.
     * @example
     * ```
     * const AppRoot = () => {
     *   const syncConfig = {
     *     flexible: true,
     *     user: currentUser
     *   };
     *
     *   return (
     *     <RealmProvider schema={[Task, User]} path={"data.realm"} sync={syncConfig}>
     *       <App/>
     *     </RealmProvider>
     *   )
     * }
     * ```
     * @param props - The {@link Realm.Configuration} for this Realm defaults to
     * the config passed to `createRealmProvider`, but individual config keys can
     * be overridden when creating a `<RealmProvider>` by passing them as props.
     * For example, to override the `path` config value, use a prop named `path`
     * e.g., `path="newPath.realm"`
     * an attribute of the same key.
     */
    RealmProvider: ReturnType<typeof createRealmProvider>;
    /**
     * Returns the instance of the {@link Realm} opened by the `RealmProvider`.
     * @example
     * ```
     * const realm = useRealm();
     * ```
     * @returns a realm instance
     */
    useRealm: ReturnType<typeof createUseRealm>;
    /**
     * Returns a {@link Realm.Collection} of {@link Realm.Object}s from a given type.
     * The hook will update on any changes to any object in the collection
     * and return an empty array if the collection is empty.
     *
     * The result of this can be consumed directly by the `data` argument of any React Native
     * VirtualizedList or FlatList.  If the component used for the list's `renderItem` prop is {@link React.Memo}ized,
     * then only the modified object will re-render.
     * @example
     * ```tsx
     * // Return all collection items
     * const collection = useQuery(Object)
     *
     * // Return all collection items sorted by name and filtered by category
     * const filteredAndSorted = useQuery(Object, (collection) => collection.filtered('category == $0',category).sorted('name'), [category]);
     * ```
     * @param type - The object type, depicted by a string or a class extending Realm.Object
     * @param query - A function that takes a {@link Realm.Collection} and returns a {@link Realm.Collection} of the same type.
     * This allows for filtering and sorting of the collection, before it is returned.
     * @param deps - An array of dependencies that will be passed to {@link React.useMemo}
     * @returns a collection of realm objects or an empty array
     */
    useQuery: ReturnType<typeof createUseQuery>;
    /**
     * Returns a {@link Realm.Object} from a given type and value of primary key.
     * The hook will update on any changes to the properties on the returned object
     * and return null if it either doesn't exists or has been deleted.
     * @example
     * ```
     * const object = useObject(ObjectClass, objectId);
     * ```
     * @param type - The object type, depicted by a string or a class extending {@link Realm.Object}
     * @param primaryKey - The primary key of the desired object which will be retrieved using {@link Realm.objectForPrimaryKey}
     * @returns either the desired {@link Realm.Object} or `null` in the case of it being deleted or not existing.
     */
    useObject: ReturnType<typeof createUseObject>;
};
/**
 * Creates Realm React hooks and Provider component for a given Realm configuration
 * @example
 * ```
 *class Task extends Realm.Object {
 *  ...
 *
 *  static schema = {
 *    name: 'Task',
 *    primaryKey: '_id',
 *    properties: {
 *      ...
 *    },
 *  };
 *}
 *
 *const {useRealm, useQuery, useObject, RealmProvider} = createRealmContext({schema: [Task]});
 * ```
 * @param realmConfig - {@link Realm.Configuration} used to open the Realm
 * @returns An object containing a `RealmProvider` component, and `useRealm`, `useQuery` and `useObject` hooks
 */
export declare const createRealmContext: (realmConfig?: Realm.Configuration) => RealmContext;
/**
 * The Provider component that is required to wrap any component using
 * the Realm hooks.
 * @example
 * ```
 * const AppRoot = () => {
 *   const syncConfig = {
 *     flexible: true,
 *     user: currentUser
 *   };
 *
 *   return (
 *     <RealmProvider schema={[Task, User]} path={"data.realm"} sync={syncConfig}>
 *       <App/>
 *     </RealmProvider>
 *   )
 * }
 * ```
 * @param props - The {@link Realm.Configuration} for this Realm, passed as props.
 * By default, this is the main configuration for the Realm.
 */
export declare const RealmProvider: import("react").FC<Omit<Partial<Realm.Configuration>, "sync"> & {
    sync?: Partial<Realm.SyncConfiguration> | undefined;
} & {
    fallback?: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | import("react").ComponentType<unknown> | null | undefined;
    closeOnUnmount?: boolean | undefined;
    realmRef?: import("react").MutableRefObject<Realm | null> | undefined;
    children: import("react").ReactNode;
}>;
/**
 * Returns the instance of the {@link Realm} opened by the `RealmProvider`.
 * @example
 * ```
 * const realm = useRealm();
 * ```
 * @returns a realm instance
 */
export declare const useRealm: () => Realm;
/**
 * Returns a {@link Realm.Collection} of {@link Realm.Object}s from a given type.
 * The hook will update on any changes to any object in the collection
 * and return an empty array if the collection is empty.
 *
 * The result of this can be consumed directly by the `data` argument of any React Native
 * VirtualizedList or FlatList.  If the component used for the list's `renderItem` prop is {@link React.Memo}ized,
 * then only the modified object will re-render.
 * @example
 * ```tsx
 * // Return all collection items
 * const collection = useQuery(Object)
 *
 * // Return all collection items sorted by name and filtered by category
 * const filteredAndSorted = useQuery(Object, (collection) => collection.filtered('category == $0',category).sorted('name'), [category]);
 * ```
 * @param type - The object type, depicted by a string or a class extending Realm.Object
 * @param query - A function that takes a {@link Realm.Collection} and returns a {@link Realm.Collection} of the same type.
 * This allows for filtering and sorting of the collection, before it is returned.
 * @param deps - An array of dependencies that will be passed to {@link React.useMemo}
 * @returns a collection of realm objects or an empty array
 */
export declare const useQuery: {
    <T>(type: string, query?: ((collection: Realm.Results<T>) => Realm.Results<T>) | undefined, deps?: readonly unknown[] | undefined): Realm.Results<T & Realm.Object<T>>;
    <T_1 extends Realm.Object<any>>(type: new (...args: any) => T_1, query?: ((collection: Realm.Results<T_1>) => Realm.Results<T_1>) | undefined, deps?: readonly unknown[] | undefined): Realm.Results<T_1>;
};
/**
 * Returns a {@link Realm.Object} from a given type and value of primary key.
 * The hook will update on any changes to the properties on the returned object
 * and return null if it either doesn't exists or has been deleted.
 * @example
 * ```
 * const object = useObject(ObjectClass, objectId);
 * ```
 * @param type - The object type, depicted by a string or a class extending {@link Realm.Object}
 * @param primaryKey - The primary key of the desired object which will be retrieved using {@link Realm.objectForPrimaryKey}
 * @returns either the desired {@link Realm.Object} or `null` in the case of it being deleted or not existing.
 */
export declare const useObject: {
    <T>(type: string, primaryKey: T[keyof T]): (T & Realm.Object<T>) | null;
    <T_1 extends Realm.Object<any>>(type: new (...args: any) => T_1, primaryKey: T_1[keyof T_1]): T_1 | null;
};
export { Realm };
export * from "./AppProvider";
export { useUser, UserProvider } from "./UserProvider";
export * from "./useAuth";
export * from "./useEmailPasswordAuth";
export * from "./types";
//# sourceMappingURL=index.d.ts.map